[{"title":"C语言函数","url":"/2023/06/05/function%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","content":"函数简介：函数和数学上的函数定义类似，C语言中的函数就是对给定的输入变量,返回对应的函数值,或者对进行一定的操作。\n不同的是在C语言的函数当中，可以为,即没有函数的输入，只是在函数体中进行一定的操作。\n最常见的函数就是main函数，之前讲过每个程序都需要有一个main函数作为程序入口，程序所进行的操作实际就是main函数里的内容。\n函数最大的意义就是可以进行模块化编程，简单来说就是对同一类问题可以只用一个函数求解，类比数学中的函数就是我们对确定的可以只编写一个程序，无论的取值，我们都可以用这一个程序来求解，这一个程序就可以成为一个模块，而需要求解的问题就可以通过对其几个子问题模块的组合来解决。\n函数分类库函数库函数包含在各个头文件里，比如平时最常用的scanf,printf也是函数（包含在&lt;stdio.h&gt;库中），除此之外&lt;cmath&gt;头文件中有定义好的各种数学运算函数，如sqrt(平方根)，floor(下取整)，pow(求幂)等等，还有&lt;cstring&gt;等各种库，只需要记住最常用的一些即可。标准库中的函数我们所要做的就是在程序中包含头文件之后直接调用。\n用户自定义函数这是重点部分，自定义函数就是我们去仿照标准库，去实现一些具有我们想要的功能的函数，具体的定义方法，声明方法等后面补充。\nmain函数程序入口，不再赘述。\n函数的使用：函数的声明和定义void myfunc(void); // 函数的声明（declaration）void myfunc(void)  // 函数的定义（definition） {    printf(\"This is my function...\");    return;}\n\n函数的声明和定义的基本语法如上，声明和定义的区别就是声明告诉了编译器有个函数叫myfunc,但是编译器不一定知道这个函数是做什么的；而定义则不仅告诉了编译器有这个函数，而且告诉了编译器这个函数可以干什么。\n之后我们细看函数定义的语法，void myfunc(void)中，前面的void代表的是返回值类型（Return Type），后面的void代表的是函数参数(Parameters)。函数的返回值可以理解为，而函数参数就可以理解为,若有多个参数用,隔开。\n返回值类型就是C语言中的数据类型，比如int,float,double,char等等，而参数则可以有多个，对应数学中的多元函数，下面给出一个求圆面积的例子：\n#define PI 3.1415926double getCircleArea(double radius){    double area = PI * radius * radius;    return area;}\n\n需要注意的是函数定义的返回值类型和在函数体中返回的类型要一致，如上面的例子中，圆面积area是double类型，函数的返回值也是double类型，因此函数体返回的语句为return area.再比如main函数一般为int main(),return 0;。\n回到开始的例子，\nvoid myfunc(void) {    printf(\"This is my function...\");    return;}\n\n之前知道C语言中void代表忽略或者没有，所以这个例子中的函数1.不需要参数。2.没有返回值。\n函数的调用：自定义函数在程序中的结构1.#include &lt;stdio.h&gt;// 函数的声明int main(){    // 调用函数    return 0;}// 函数的定义\n\neg:\n#include &lt;stdio.h&gt;void myfunc(); // 声明int main(){    myfunc();    return 0;}void myfunc(){    // To do ...    return;}\n\n2.#include &lt;stdio.h&gt;// 函数的声明兼定义int main(){    // 调用函数    return 0;}\n\neg:\n#include &lt;stdio.h&gt;void myfunc(){    // To do ...    return;}int main(){    myfunc();    return 0;}\n\n调用时返回值类型与等号左值相对应eg:\n#include &lt;stdio.h&gt;#define PI 3.1415926double getCircleArea(double radius){    double area = PI * radius * radius;    return area;}int main(){    double radius = 4;    double area = getCircleArea(radius);    return 0;}\n\n嵌套调用：函数不止在主函数中可以调用，在一个函数中可以调用另一个函数eg:见ppt Page.19\n需要注意的是如果函数A在函数B中被调用,A一定要在B的定义之前被声明。\n变量：形参和实参：形参是指函数定义和声明中的参数，而实参是指调用函数时传入的参数\neg:\n#include &lt;stdio.h&gt;int add(int A, int B){    return A + B;}int main(){    int a = 4, b = 5;    int c = add(a, b);    return 0;}\n\n上述代码中A,B为形参， a,b为实参。（形参和实参可以同名）\n变量的作用域：一般来说，变量的作用域就是定义变量的那一个语句块（那一对大括号之间）。\neg:\n#include &lt;stdio.h&gt;int global;int main(){    int a;    if(a == 0)    {        int b;    }    else    {        int c;    }    return 0;}\n\n如上述例子，变量a的作用域是整个main函数，而b，c的作用域则是它们各自所在的if语句块。\na,b,c都统称局部变量，除此之外，也有特殊变量叫全局变量，它定义在main函数之前，作用域是整个程序。\n注意，自定义函数的参数属于局部变量，它的作用域就是函数体内。\n变量类型：auto和register逐渐弃用，看看ppt就行\nstatic:用在局部变量，延长变量寿命，在函数体中的变量若没有static,每次调用后都会被释放，每次调用时都是重新申请资源，而static修饰后每次调用都是在上次调用的基础上。\n用在全局变量，单文件没影响，多文件本来全局变量是多个文件互通，加static修饰后只在当前文件内可用。\nextern:在其他文件内定义的变量使用前声明时用到extern.\n","categories":["语法总结","C语言"],"tags":["C语言"]},{"title":"Hello World","url":"/2023/06/05/hello-world/","content":"经典Hello World开局cout&lt;&lt;\"Hello World\"&lt;&lt;endl;\n","categories":["杂谈"],"tags":["hello world"]},{"title":"C语言输入输出总结","url":"/2023/06/05/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/","content":"C语言输入输出总结%c —— char, 单个字符类型#include &lt;stdio.h&gt;int main (){    char ch; //或者 unsigned char ch;    scanf(\"%c\",&amp;ch);    printf(\"%c\",ch);    return 0;}\n\n%d —— int, 十进制整型#include &lt;stdio.h&gt;int main (){    int a;    scanf(\"%d\",a);    printf(\"%d\",a);    return 0;}\n\n(拓展：输出时%nd ，等宽输出，宽度为n，不等宽时补空格；%0nd或者%.nd补0)\n#include &lt;stdio.h&gt;int main (){    const int n = 8;    int count[n] = {1,2,3,4,17,18,19,20};    for (int i = 0; i &lt; n; i++)    {        printf(\"%2d\\n\",count[i]);    }    return 0;}\n\n输出结果：\n 1 2 3 417181920\n\n#include &lt;stdio.h&gt;int main (){    const int n = 8;    int count[n] = {1,2,3,4,17,18,19,20};    for (int i = 0; i &lt; n; i++)    {        printf(\"%02d\\n\",count[i]);       //或者printf(\"%.2d\\n\",count[i]);    }    return 0;}\n\n输出结果：\n0102030417181920\n\n%ld —— long, 长整型#include &lt;stdio.h&gt;int main (){    long a;    scanf(\"%ld\",&amp;a);    printf(\"%ld\",a);    return 0;}\n\n%lld —— long long, 长整型#include &lt;stdio.h&gt;int main (){    long long a;    scanf(\"%lld\",&amp;a);    printf(\"%lld\",a);    return 0;}\n\n%hd —— short，短整型#include &lt;stdio.h&gt;int main (){    short a;    scanf(\"%hd\",&amp;a);    printf(\"%hd\",a);    return 0;}\n\n（int，long，longlong，short区别）int                -2147483648~2147483647(10位十进制数)\nshort            -32768~32767(5位十进制数)\nlong             -2147483648~2147483647(10位十进制数)\nlong long     -9223372036854775808~9223372036854775807(20位十进制数)\n%f ——float, 单精度浮点数#include&lt;stdio.h&gt;int main(){    float a;    scanf(\"%f\",&amp;a);    printf(\"%f\",a);    return 0;}\n\n%lf —— double, 双精度浮点数#include&lt;stdio.h&gt;int main(){    float a;    scanf(\"%lf\",&amp;a);    printf(\"%lf\",a);    return 0;}\n\n(拓展：%.nf或%.nlf可以输出四舍五入后的n位小数)\n","categories":["语法总结","C语言"],"tags":["C语言","语法"]},{"title":"洛谷P1124题解——文件压缩","url":"/2023/06/05/%E6%B4%9B%E8%B0%B7P1124%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/","content":"题目原题链接：P1124-文件压缩\n原题：\n题目描述\n该算法具体如下：对一个长度为 n 的字符串 S，首先根据它构造 n 个字符串，其中第 i 个字符串由将 S 的前 i−1 个字符置于末尾得到。然后把这 n 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们在 S 中的位置从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 S′，它的长度也是 n，并且包含了 S 中的每一个字符。最后输出 S′ 以及 S 的首字符在 S′ 中的位置 p。\n举例：S 是 example\n\n构造 n 个字符串。\nexamplexampleeampleexmpleexapleexamleexampeexampl\n将字符串排序。\nampleexexampleeexamplleexampmpleexapleexamxamplee\n压缩结果。\n，\n\n\n在读题过程中不难发现，当我们将压缩结果按字典序排列时可以得到中首字母序列，从而我们可以得到每个字母的前驱或者后继。因此我们可以利用这个规律来找到原字符串。这里我们选择先找到尾字符，然后找每个字母的前驱，最后反向输出，这样做的原因是正向寻找时按照压缩字符串寻找，无规律，容易乱序，而逆向寻找靠排序串，不致乱序。\nc++实现#include&lt;bits/stdc++.h&gt;//可食用头文件using namespace std;int main(){    int n,shou,now;//n为S串长度，shou即为题目中p，首字母所在压缩后的位置，now为现在进行到哪个位置了    cin&gt;&gt;n;//输入    char a[n],b[n],ans[n];//a——压缩串，b——字典序串，ans——答案串    cin&gt;&gt;a&gt;&gt;shou;//万能cin    for(int i=0;i&lt;n;i++)b[i]=a[i];//a带给b    sort(b,b+n);//自动排序    for(int i=0;i&lt;n;i++)//首先按首字母找到最后一个字母    {        if(b[i]==a[shou-1])        {            now=i;            b[i]=')';//标记，退出            break;        }    }    ans[0]=a[now];//计入答案    for(int i=1;i&lt;n;i++)//ans[i]表示倒数第i+1个字母    {        for(int j=n-1;j&gt;=0;j--)//从后往前搜到第一个与原char串匹配的字典序串        {            if(b[j]==a[now])            {                now=j;//更改现在所在位置，即跳到前一个字母                ans[i]=a[now];//计入答案                b[j]=')';//标记                break;            }        }        }    for(int i=n-1;i&gt;=0;i--)cout&lt;&lt;ans[i];//倒序输出}\npython实现n=int(input())#字符串长度s=input()#压缩串pos=int(input())#压缩串中首字母位置pos=pos-1box=[]#压缩串得到列表for i in range(n):    box.append(s[i])boxs=box.copy()boxs.sort()#字典序列表res=[]for i in range(0,n):    if boxs[i]==box[pos]:        pos=i        boxs[i]='0'        res.append(box[pos])        break    for j in range(1,n):    for i in range(n-1,-1,-1):        if boxs[i]==box[pos]:            pos=i            res.append(box[pos])            boxs[i]='0'            break            ans=\"\"res.reverse()for each in res:    ans=ans+eachprint(ans)\n","categories":["题解"],"tags":["python","洛谷","c++"]},{"title":"VMware 让虚拟机通过主机代理上网","url":"/2023/06/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware-%E7%94%A8%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/","content":"Ubuntu 20.04.6 LTS\nVMware Workstation 17 Pro 17.0.0\nwindows 10\n首先更改虚拟机的网络适配器设置如下：\n\n之后打开代理软件，允许局域网连接并记录端口号（v2rayN为例）：\n\n命令行输入ipconfig，得到主机ip地址：\n\n打开Ubuntu网络设置，代理设置改为手动，输入本机ip地址，只需要填端口号即可：\n\n需要注意，虽然之前得到监听端口为8888,但在v2rayN中局域网连接的端口一般为为监听端口+2~+3，因此此处端口为8890，如下图：\n\n至此虚拟机就可以用宿主机的代理愉快上网啦：\n\n","categories":["虚拟机"],"tags":["虚拟机","VMware"]}]