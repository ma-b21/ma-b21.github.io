[{"title":"C语言输入输出总结","url":"/2023/06/05/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/","content":"C语言输入输出总结%c —— char, 单个字符类型#include &lt;stdio.h&gt;int main (){    char ch; //或者 unsigned char ch;    scanf(\"%c\",&amp;ch);    printf(\"%c\",ch);    return 0;}\n\n%d —— int, 十进制整型#include &lt;stdio.h&gt;int main (){    int a;    scanf(\"%d\",a);    printf(\"%d\",a);    return 0;}\n\n(拓展：输出时%nd ，等宽输出，宽度为n，不等宽时补空格；%0nd或者%.nd补0)\n#include &lt;stdio.h&gt;int main (){    const int n = 8;    int count[n] = {1,2,3,4,17,18,19,20};    for (int i = 0; i &lt; n; i++)    {        printf(\"%2d\\n\",count[i]);    }    return 0;}\n\n输出结果：\n 1 2 3 417181920\n\n#include &lt;stdio.h&gt;int main (){    const int n = 8;    int count[n] = {1,2,3,4,17,18,19,20};    for (int i = 0; i &lt; n; i++)    {        printf(\"%02d\\n\",count[i]);       //或者printf(\"%.2d\\n\",count[i]);    }    return 0;}\n\n输出结果：\n0102030417181920\n\n%ld —— long, 长整型#include &lt;stdio.h&gt;int main (){    long a;    scanf(\"%ld\",&amp;a);    printf(\"%ld\",a);    return 0;}\n\n%lld —— long long, 长整型#include &lt;stdio.h&gt;int main (){    long long a;    scanf(\"%lld\",&amp;a);    printf(\"%lld\",a);    return 0;}\n\n%hd —— short，短整型#include &lt;stdio.h&gt;int main (){    short a;    scanf(\"%hd\",&amp;a);    printf(\"%hd\",a);    return 0;}\n\n（int，long，longlong，short区别）int                -2147483648~2147483647(10位十进制数)\nshort            -32768~32767(5位十进制数)\nlong             -2147483648~2147483647(10位十进制数)\nlong long     -9223372036854775808~9223372036854775807(20位十进制数)\n%f ——float, 单精度浮点数#include&lt;stdio.h&gt;int main(){    float a;    scanf(\"%f\",&amp;a);    printf(\"%f\",a);    return 0;}\n\n%lf —— double, 双精度浮点数#include&lt;stdio.h&gt;int main(){    float a;    scanf(\"%lf\",&amp;a);    printf(\"%lf\",a);    return 0;}\n\n(拓展：%.nf或%.nlf可以输出四舍五入后的n位小数)\n","categories":["语法总结","C语言"],"tags":["C语言","语法"]},{"title":"xv6-Lab3","url":"/2023/07/05/Lab3_Report/","content":"Lab3 page tablesSpeed up system calls主要思路根据题中所给的Hints以及参考书的Chapter 3,要实现对getpid()的加速，就是将进程的pid信息存放在内核和用户共用的一片存储空间中，从而在ugetpid()的时候程序不用陷入内核态，实现对getpid()的加速。实现流程如下：\n\n首先在kernel/proc.h中添加如下代码来作为上述共享空间：struct usyscall *usyspage;   // 用户与内核共享页\n接着在kernel/proc.c中添加如下代码来为这个页面分配空间并将目标值装入页面：static struct proc*allocproc(void){  ...  // Allocate a trapframe page.  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0){    freeproc(p);    release(&amp;p-&gt;lock);    return 0;  }  // 给共享页分配空间(add)  if((p-&gt;usyspage = (struct usyscall *)kalloc()) == 0){    freeproc(p);    release(&amp;p-&gt;lock);    return 0;  }  p-&gt;usyspage-&gt;pid = p-&gt;pid;  ...  return p;}\n在销毁进程时要记得将页面空间释放并避免野指针(kernel/proc.c)：static voidfreeproc(struct proc *p){ ...  if(p-&gt;usyspage)    kfree((void*)p-&gt;usyspage);  p-&gt;usyspage = 0;  ...}\n在页表中建立映射(kernel/proc.c),注意题中要求，该页的权限为用户只读:// Create a user page table for a given process, with no user memory,// but with trampoline and trapframe pages.pagetable_tproc_pagetable(struct proc *p){  ...  // 建立从USYSCALL到p-&gt;usyspage的映射，权限为用户只读  if(mappages(pagetable, USYSCALL, PGSIZE,              (uint64)(p-&gt;usyspage), PTE_R | PTE_U) &lt; 0){    uvmfree(pagetable, 0);    return 0;  }  // map the trampoline code (for system call return)  // at the highest user virtual address.  // only the supervisor uses it, on the way  // to/from user space, so not PTE_U.  ...}\n同样在进程结束释放页表的时候要记得取消映射(kernel/proc.c)：// Free a process's page table, and free the// physical memory it refers to.voidproc_freepagetable(pagetable_t pagetable, uint64 sz){  ...  uvmunmap(pagetable, USYSCALL, 1, 0);  uvmfree(pagetable, sz);}\n\nQ:Which other xv6 system call(s) could be made faster using this shared page? Explain how.\n\n\n\n系统调用sys_sbrk也可以用此页来加速，因为该函数返回的是myproc()-&gt;sz,因此我们可以将myproc()-&gt;sz也在进程初始化的时候存在该页中，就像存进程的pid一样，用同样的原理可以加速此系统调用。\nPrint a page table主要思路根据Hints来写，首先要输出所有页表项我们需要对三层页表进行遍历，页表是树状结构，遍历的历程参考Hints给出的freewalk()函数。\n\n在kernel/defs.h中定义vmprint函数：void            vmprint(pagetable_t);\n在kernel/exec.c中添加题目要求的代码：...if(p-&gt;pid==1) vmprint(p-&gt;pagetable);return argc; // this ends up in a0, the first argument to main(argc, argv)...\n接着在kernel/vm.c中实现vmprint函数(仿照freewalk函数)：static uint64 depth = 0; // 来记录递归搜索深度voidvmprint(pagetable_t page){  if(depth == 0)           // 根地址打印  {    printf(\"page table %p\\n\", page);  }  for(int i = 0; i &lt; 512; ++i)  // 遍历页面上的页表项  {    pte_t pte = page[i];       if(pte &amp; PTE_V)        // 页表项有效    {      for(int j = 0; j &lt;= depth; ++j)      {         printf(\" ..\");      }      printf(\"%d: pte %p pa %p\\n\", i, (uint64)pte, (uint64)PTE2PA(pte));  // 分别打印虚拟地址和物理地址      if(depth &lt; 2) // 一级或二级页表递归搜索子页表项      {        depth ++;        vmprint((pagetable_t)PTE2PA(pte));        depth --;      }    }   }}\n\n\nQ:Explain the output of vmprint in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? What does the third to last page contain? \n\nFigure 3.4如下：\n\n对于三层页表的存储内容，我们需要对exec函数进行分析，因为页表在这里被创建。首先我们可以看到exec函数中与内存操作相关的第一处是如下代码：\n// Load program into memory.for(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph)){  if(readi(ip, 0, (uint64)&amp;ph, off, sizeof(ph)) != sizeof(ph))    goto bad;  if(ph.type != ELF_PROG_LOAD)    continue;  if(ph.memsz &lt; ph.filesz)    goto bad;  if(ph.vaddr + ph.memsz &lt; ph.vaddr)    goto bad;  if(ph.vaddr % PGSIZE != 0)    goto bad;  uint64 sz1;  if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)    goto bad;  sz = sz1;  if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; 0)    goto bad;}\n由此page 0所存储的应该是这些数据，如代码段，数据段等.\n接着涉及内存操作的代码如下：\n// Allocate two pages at the next page boundary.// Make the first inaccessible as a stack guard.// Use the second as the user stack.sz = PGROUNDUP(sz);uint64 sz1;if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W)) == 0)  goto bad;sz = sz1;uvmclear(pagetable, sz-2*PGSIZE);sp = sz;stackbase = sp - PGSIZE;\n这段代码申请了两页的空间，其中第一页page 1作为Figure 3.4中guard page段,第二页作为Figure 3.4中stack段。\n由函数uvmclear的定义，page 1的PTE_U位被置为0,因此用户程序无法访问page 1。\n由Figure 3.4，第三页到最后一页包括了heap,unused,trapframe,trampoline.\nDetect which pages have been accessed主要思路本题要求我们对给定的有限个数的页面，程序可以检查这些页面是否被访问过，并且将结果编成bitmask输出到用户空间的指定地址。\n首先需要确定怎么去查询一个页面是否被访问：参考RISC-V privileged instructions中的Figure 4.18：\n\n以及page 81的如下描述：\n\nEach leaf PTE contains an accessed (A)and dirty (D) bit.The A bit indicates the virtual page hasbeen read,written,or fetched from since the last time the A bit was cleared.The D bit indicatesthe virtual page has been written since the last time the D bit was cleared.\n\n我们知道可以用PTE_A作为页面是否被访问的标志，它的值是PTE的第六位(从零开始)，因此我们在kernel/riscv.h中添加如下代码：\n#define PTE_A (1L &lt;&lt; 6)\n若PTE &amp; PTE_A == 1,则说明此页面在检查前被访问过。\n如何去得到一页中的PTE呢？根据Hints,我们可以用walk函数，它可以找到一个虚拟地址对应的PTE，返回其physical address。\n再根据Hints的第8条，我们需要在检查完毕后将PTE_A位置零，因为检查本身相当于一次访问，若不置零则PTE_A位必然是1，下一次进行检查时就可能出现页面并未被访问但是PTE_A位为1的情况。这要求我们在检查完一个页面后就将PTE的第六位置零，参考如何将一个二进制值的指定位设置为指定的值,将二进制数x的第n位设置为a的公式为x = ((x&amp;(1 &lt;&lt; n)) ^ x) ^ (a &lt;&lt; n)。\n在遍历的过程中如何设置bitmask呢？我采用如下代码：\nif(PTE_FLAGS(*pte) &amp; PTE_A)  // 访问位为1，代表被访问过{  maskbits |= (1L &lt;&lt; i);}\n这样maskbits的第i位为1则表示第i页被访问过。\n综合以上分析以及Hints中所给的其他的提示，最终补全sys_pgaccess代码如下：\nintsys_pgaccess(void){  // lab pgtbl: your code here.  uint64 base;        // 待检查页面起始地址  int pagenum;        // 待检查页面数  uint64 usraddr;     // 等待输出结果的用户空间地址  // 获取参数  argaddr(0, &amp;base);  argint(1, &amp;pagenum);  argaddr(2, &amp;usraddr);  // bitmask  uint64 maskbits = 0;  struct proc* p = myproc();  for(int i = 0; i &lt; pagenum; ++i)  {    pte_t* pte = walk(p-&gt;pagetable, base + i * PGSIZE, 0);  // 获取第i页的第0个页表项映射的物理地址    if(pte == 0)  panic(\"page not exist!\");    if(PTE_FLAGS(*pte) &amp; PTE_A)  // 访问位为1，代表被访问过    {      maskbits |= (1L &lt;&lt; i);    }    *pte = ((*pte &amp; PTE_A) ^ *pte) ^ 0;  // 将PTE_A置零  }    if (copyout(p-&gt;pagetable, usraddr, (char *)&amp;maskbits, sizeof(maskbits)) &lt; 0) // 将bitmask的结果输出到用户空间    panic(\"sys_pgacess copyout error\");    return 0;}\n\nLab3参考链接\nMIT 6.S081 2020 LAB3记录\n6.S081 Lab3 page tables\nxv6-labs-2022 Lab3 page tables 详解\n\n","categories":["xv6-Lab","操作系统"],"tags":["操作系统","MIT-xv6","c"]},{"title":"xv6-Lab1","url":"/2023/07/05/Lab1_Report/","content":"Lab 1sleep主要思路\n检查参数个数\n\n通过对argc进行判断，sleep操作argc的值应为2.\n\n\n系统调用sleep()\n\n函数原型为sleep(int),因此要先将argv[1]参数转换为int类型再进行系统调用sleep().\n\n\n代码如下：\n#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"int main(int argc, char* argv[]){    if(argc &lt; 2 || argc &gt; 2){        fprintf(2, \"Usage like \\\"sleep clockTime\\\"\\n\"); // 实验要求参数为一个整数        exit(1); // 异常退出    }    int times = atoi(argv[1]); // 调用系统调用sleep参数为int类型    sleep(times);    exit(0);}\n\npingpong主要思路\n建立管道\n\n因为管道通信为单向，因此需要两条管道.\n\n\n建立子进程\n\n注意用fork函数建立子进程后在子进程中其返回值为0，父进程中其返回值为子进程PID，若建立失败返回值为负.\n\n\n读写操作\n\n注意write函数为非阻塞式，而read函数为阻塞式\n\n\n题目相关\n\n本题中评分时输出格式要求与样例输出一致，而非题目描述，即”pid:”后面有一空格.\n\n\n代码如下：\n#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"int main(int argc, char* argv[]){    int fToc[2], cTof[2]; // 分别建立父进程到子进程,子进程到父进程的管道.    pipe(fToc);    pipe(cTof);    int pid = fork(); // 建立子进程    if(pid &lt; 0)    {        fprintf(2, \"error in fork !\"); // 若进程建立失败会返回负值    }    else if(pid &gt; 0) // 父进程中fork返回值为正    {        close(fToc[0]); // 关闭子进程读端        close(cTof[1]); // 关闭子进程写端        write(fToc[1], \"ping\", 4); // 向子进程发送1位数据        close(fToc[1]); // 关闭父进程写端        char* readBuf = (char*)malloc(sizeof(char) * 4); // 申请读入数据流空间        int fatherPID = getpid(); // 获取父进程PID        read(cTof[0], readBuf, 4); // 从子进程中接收数据（阻塞式）        close(cTof[0]); //关闭父进程读端        fprintf(2, \"%d: received %s\\n\", fatherPID, readBuf); // 按实验要求格式输出        free(readBuf); // 释放读入数据流空间    }    else // 子进程中fork返回值为0    {        close(fToc[1]); // 关闭父进程写端        close(cTof[0]); // 关闭父进程读端        char* readBuf = (char*)malloc(sizeof(char) * 4); // 申请读入数据流空间        int childPID = getpid(); // 获取子进程PID        read(fToc[0], readBuf, 4); // 从父进程中接收数据（阻塞式）        close(fToc[0]); // 关闭子进程读端        fprintf(2, \"%d: received %s\\n\", childPID, readBuf); // 按实验要求格式输出        write(cTof[1], \"pong\", 4); // 向父进程发送1位数据        close(cTof[1]); // 关闭子进程写端        free(readBuf); // 释放读入数据流空间    }    exit(0);}\n\n参考链接\n进程间通信，管道pipe函数详解\nLinux中fork函数详解\n\nprimes主要实现思路\n主函数\n\n主函数先建立一个与子进程通信的管道，将2-35的数据都写入管道中，接着建立子进程，子进程递归调用函数，该递归函数负责筛出质数.\n\n\n递归函数\n\n声明：void primes(int fToc[2]),其中fToc[2]是与父进程间的通信管道。\n功能：负责读取父进程筛选后剩下的数字，函数体内首先读取一个整数，若读取成功则该数为本次递归基质数，若失败则说明筛选结束。 读取成功后继续对管道进行读取，筛选出不是基质数倍数的数字，创建新管道进行写入，然后建立子进程继续递归执行此函数，此时父进程等待子进程结束。\n\n\n代码如下：\n#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"// 用来递归的创建子进程及管道void primes(int fToc[2]){    int count = 0;           // 未被筛的数字的个数    close(fToc[1]);          // 与父进程管道的写端    int numbers[34] = { 0 }; // 储存未被筛的数字    int base;                // 本次递归筛选的基质数    int readSuccess = 0;     // 数据读取成功标志    readSuccess = read(fToc[0], &amp;base, sizeof(int)); // 读取基质数        if(readSuccess == 0)  exit(0); // 没有基质数，即管道内为空，子进程退出        fprintf(2, \"prime %d\\n\", base); // 按照题述格式输出本次递归基质数    // 继续读取数据    readSuccess = read(fToc[0], &amp;numbers[count], sizeof(int));    while(readSuccess &gt; 0)    {        if(numbers[count] % base != 0) count++;        readSuccess = read(fToc[0], &amp;numbers[count], sizeof(int));    }    close(fToc[0]); // 关闭读端        int nfToc[2]; // 创建与子进程通信的新管道    pipe(nfToc);    if(fork() == 0) // 子进程继续递归筛质数    {        primes(nfToc);    }    else // 父进程关闭管道读端，并写入本次递归未筛选的数字，之后等待子进程退出    {        close(nfToc[0]);        write(nfToc[1], &amp;numbers, count * sizeof(int));        close(nfToc[1]);        wait(0);        exit(0);    }}int main(int argc, char* argv[]){    int number[34];  // 存2-35的数字    for(int i = 0; i &lt; 34; ++i)    {        number[i] = i + 2;    }        int fToc[2]; // 建立与子进程间通信管道    pipe(fToc);    if(fork() == 0) // 子进程递归筛质数    {        primes(fToc);    }    else // 父进程关闭管道读端，并写入本次递归未筛选的数字，之后等待子进程退出     {        close(fToc[0]);        write(fToc[1], &amp;number, 34 * sizeof(int));        close(fToc[1]);        wait(0);        exit(0);    }    exit(0);}\n\n参考链接\n父进程等待子进程结束 waitpid wait\n\nfind主要思路\n检查参数\n参数个数不为3个时输出错误\n\n\nfind\n当前path为文件时直接对比文件名与目标文件名\n当前path为目录时遍历其子文件，递归进行搜索\n\n\n\n实现难点\n获取文件信息\n\nfstat(int, struct stat*),int为文件句柄，struct stat为存文件信息的结构\n\n\n遍历子目录\n\n利用path + \"/\" + 子文件名得到新path进行递归\n子文件名通过read(fd, &amp;de, sizeof(de))得到de.name,其中fd为文件句柄，de为建立的目录结构\n注意在遍历时要跳过.,..以及无效目录\n\n\n代码如下：\n#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\"// 通过路径获取文件名char* fmtname(char *path){    char *p;     for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)        ;    p++;    return p;}// 在path及其子目录下查找名为fileName的文件void find(char* path, char*fileName){    char buf[512], *p; // 缓冲区及其指针    int fd; // 文件句柄    struct dirent de; // 目录结构    struct stat st; // 文件信息结构    if((fd = open(path, 0)) &lt; 0) // 打开path目录文件    {        fprintf(2, \"ls: cannot open %s\\n\", path);        return;    }    if(fstat(fd, &amp;st) &lt; 0) // 获取文件信息    {        fprintf(2, \"ls: cannot stat %s\\n\", path);        close(fd);        return;    }    switch(st.type){    case T_FILE: // 如果是文件则将文件名与目标文件名比较        if(!strcmp(fmtname(path), fileName)) printf(\"%s\\n\", path);        break;    case T_DIR: // 如果是目录文件则递归查找目录内的所有文件        if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) // 目录长度超过最大限制        {            printf(\"ls: path too long\\n\");            break;        }           strcpy(buf, path); // 将路径拷贝到缓冲区        p = buf+strlen(buf); // 将指针指向缓冲区尾        *p++ = '/'; // 路径格式        while(read(fd, &amp;de, sizeof(de)) == sizeof(de)) // 读到子文件        {            if(de.inum == 0 || !strcmp(de.name, \".\") || !strcmp(de.name, \"..\")) // 过滤无效目录和.，..两个目录                continue;            memmove(p, de.name, DIRSIZ); // 将子文件名拷贝到缓冲区            p[DIRSIZ] = 0; // 加尾符'\\0'            if(stat(buf, &amp;st) &lt; 0) // 获取子目录信息            {                printf(\"ls: cannot stat %s\\n\", buf);                continue;            }            find(buf, fileName); // 子目录有效递归查找    }    break;  }  close(fd); // 关闭文件}int main(int argc, char* argv[]){    if(argc &gt; 3 || argc &lt; 3) // 检查参数个数    {        printf(\"The usage like \\\"find path file_name\\\" ...\\n\");        exit(1);    }    find(argv[1], argv[2]); // 寻找文件    exit(0);}\n\n参考链接\nMIT 6.S081课程Lab Util Find全网最详细思路分享/个人学习笔记\n\nxargs主要思路\n检查参数\n\n若参数个数小于2则异常退出\n\n\n建立新字符串数组作为exec执行参数\n\n新字符串数组nargv,其初值等于argv数组的1-（argc - 1）项\n从标准输入流中读取数据\n将上述数据通过\\n分开，存入字符串数组中\n遍历字符串数组，分别将其当作nargv中的下一个元素，将nargv的末元素置为0，建立子进程以nargv作为参数执行exec函数\n\n\n代码如下：\n#include \"kernel/param.h\"#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"int main(int argc, char* argv[]){    if(argc &lt; 2) // 检查参数个数    {        fprintf(2, \"Need more arguments...\");        exit(1);    }    char *nargv[16]; // xargs命令要调用的参数    int index = 0;    for(int i = 1; i &lt; argc; ++i)    {        nargv[index ++] = argv[i];    }    char buf[512]; // 从标准输入流中读取数据    char* buff = buf; // 用于后续分割buf中的不同行    char* p = buf; // 用于将输入接到buf的尾部    int readBuf;    while((readBuf = read(0, p, 16)) &gt; 0) // 读入标准输出的内容    {        p += readBuf;        *p = '\\0';        if(strlen(buf) &gt; 512)        {            fprintf(2, \"too many arguments\");            exit(1);        }    }    char* nargvMem[32]; // 第i行的输出为nargvMen[i]    int nindex = 0;    for(char* q = buf; q != p; ++q) // 对buf根据不同行进行分割    {        if(*q == '\\n')        {            *q = '\\0';            nargvMem[nindex ++] = buff;            buff = q + 1;        }    }    for(int i = 0; i &lt; nindex; ++i) // 用nargv进行执行exec()操作，通过更改nargv[index]的值实现不同行输出的执行    {        nargv[index ++] = nargvMem[i];        nargv[index] = 0;        if(fork() == 0)        {            exec(nargv[0], nargv);            exit(0);        }        else        {            index--;            wait(0);        }    }    exit(0);}\n\n参考链接\nLinux grep 命令\nxargs原理及用法详解\n\n","categories":["xv6-Lab","操作系统"],"tags":["操作系统","MIT-xv6","c"]},{"title":"xv6-Lab2","url":"/2023/07/05/Lab2_Report/","content":"Lab 2using gdb\nQ1:Looking at the backtrace output,which function called syscall?\n\n执行backtrace后结果如下：\n\n由图可知是函数usertrap()调用了syscall()函数.\n\nQ2:What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent?(Hint:look user/initcode.S,the first user program xv6 starts.)\n\n首先输入两次n之后执行结果如下：\n\n语句struct proc *p = myproc()执行完毕，接着执行p/x *p看p的内容如下：\n\n此时查看p-&gt;trapframe-&gt;a7的值：\n\n得到a7的值为7。根据user/initcode.S以及参考书第二章内容可知寄存器a7保存了系统将要执行的系统调用号，这里的系统调用号为7,由kernel/syscall.h的内容（下图）可知系统调用为SYS_exec。\n\n\nQ3:What was the previous mode that the CPU was in?\n\n在gdb中输入p /x $sstatus得到如下结果：\n\n其值转换为二进制为：0b100010,在参考书RISC-V privileged instructions中找到sstatus的值定义如下：\n\n同时对于其SPP位有描述如下：\n\nThe SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction (see Section 3.3.2) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.\nSPP 位指示进入管理员模式之前 hart 执行的特权级别。 当采取陷阱时，如果陷阱源自用户模式，则 SPP 设置为 0，否则设置为 1。 当执行 SRET 指令（见第 3.3.2 节）从陷阱处理程序返回时，如果 SPP 位为 0，则特权级别设置为用户模式，如果 SPP 位为 1，则设置为超级用户模式； 然后将 SPP 设置为 0。\n\n因此，因为此时SPP位为0,所以在syscall之前系统处于用户模式(User mode)。\n\nQ4:Write down the assembly instruction the kernel is panicing at.Which register corresponds to the varialable num?\n\n首先按照指导将kernel/syscall.c中syscall函数中的num = p-&gt;trapframe-&gt;a7改为num = * (int *) 0,接着执行make qemu得到如下输出：\n\n在kernel/kernel.asm中查找上图中的sepc值，得到结果如下图：\n\n对应的汇编指令为lw a3,0(zero),由参考书RISC-V Assembly Language,\n\n这条汇编代码代表：将内存中地址从0开始的一个字word(2bytes)大小的数据加载到寄存器a3中。\n\nQ5:Why does the kernel crash?Hint:look at figure 3-3 in the text;is address 0 mapped in the kernel address space?Is that confirmed by the value in scause above?(Seedescription of scause in RISC-V privileged instructions)\n\n首先按照实验要求在上文panic的代码处打上断点并继续执行，结果如下：\n\n此时再次输入n并执行会引起内核panic,如下：\n\n使用Ctrl+C来退出当前线程并打印scause的值如下：\n\n接着开始分析：首先根据参考书book-riscv-rev3中的Figure 3.3(如下图)，\n\n内核地址空间基地址为0x80000000,因此代码中的数据地址0不映射到内核地址空间中，因此内核会崩溃。\n而scause的值为13，在参考书RISC-V Assembly Language的Table 8.6(如下图)中可以查到代码13对应Load page fault，验证了结论。\n\n\nQ6:What is the name of the binary that was running when the kernel paniced? What is its process id (pid)? \n\n首先重启qemu和gdb执行如下命令:\n\n为了获得进程pid,执行如下命令：\n\n因此\nname = initcode\\000\\000\\000\\000\\000\\000\\000;\npid = 1.\nSystem call tracing主要思路\n根据题中所给的Hints来修改程序\nMakefile:Add $U/_trace to UPROGS.\nuser/user.h: 增加trace函数的声明，如下：int trace(int);\nuser/usys.pl:增加如下代码：entry(\"trace\");\nkernel/proc.h:在struct proc中添加成员变量mask,用于存储trace函数的参数1 &lt;&lt; SYS_call:struct proc{  uint64 mask;  ...};\nkernel/sysproc.c:增加函数sys_trace如下：uint64sys_trace(void){  int mask;  argint(0, &amp;mask); // 从系统调用中获得参数mask  struct proc* p = myproc();  p-&gt;mask = mask; // 将当前进程的mask值设为获取的参数  return 0;}\n用于在调用trace时来接收参数mask.\nkernel/proc.c:在fork函数中增加如下代码：fork(void){  ...  np-&gt;sz = p-&gt;sz;  // 复制trace mask值到子进程  np-&gt;mask = p-&gt;mask;  // copy saved user registers.  *(np-&gt;trapframe) = *(p-&gt;trapframe);  ...}\n上述代码实现将掩码mask从父进程传到子进程.\nkernel/syscall.h:增加系统调用号SYS_trace:#define SYS_trace 22\nkernel/syscall.c:\n增加函数声明：extern uint64 sys_trace(void);\n增加syscalls的取值：static uint64 (*syscalls[])(void) = {...[SYS_close]   sys_close,[SYS_trace]   sys_trace,};\n增加系统调用名的字符串数组：// 用来在打印trace函数运行结果时输出系统调用名称static char* syscall_names[] = {  \"\",  \"syscall fork\",  \"syscall exit\",  \"syscall wait\",  \"syscall pipe\",  \"syscall read\",  \"syscall kill\",  \"syscall exec\",  \"syscall fstat\",  \"syscall chdir\",  \"syscall dup\",  \"syscall getpid\",  \"syscall sbrk\",  \"syscall sleep\",  \"syscall uptime\",  \"syscall open\",  \"syscall write\",  \"syscall mknod\",  \"syscall unlink\",  \"syscall link\",  \"syscall mkdir\",  \"syscall close\",  \"syscall trace\",};\n修改syscall函数：voidsyscall(void){  ...  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {    // Use num to lookup the system call function for num, call it,    // and store its return value in p-&gt;trapframe-&gt;a0    p-&gt;trapframe-&gt;a0 = syscalls[num]();    if((p-&gt;mask &gt;&gt; num) &amp; 0b1){ // 如果mask的值译码后等于该系统调用的系统调用号，则打印相关信息      printf(\"%d: %s -&gt; %d\\n\", p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);    }  } else {    printf(\"%d %s: unknown sys call %d\\n\",      p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = -1;  }}\n上述改动中内层条件判断的语句就是将mask进行解码，然后与1作比较，若相等则输出该系统调用.\n\n\n\n\n\n经过以上对内核的修改，成功实现了系统调用trace.\nsysinfo主要思路\n和上个实验一样按照Hints来逐步完成，本实验的主要目的是完成系统调用sysinfo来统计系统非空闲进程数量和空闲空间字节数.\n首先是将系统调用添加到内核中,参考System call tracing,进行如下操作：\nAdd $U/_sysinfotest to UPROGS in Makefile\n在user/user.h中进行系统调用函数的声明：struct sysinfo;...int sysinfo(struct sysinfo *);...\n在user/usys.pl中添加如下代码：...entry(\"trace\");entry(\"sysinfo\");\n在kernel/syscall.h中添加系统调用号：#define SYS_sysinfo 23\n在kernel/syscall.c中添加如下改动：...extern uint64 sys_info(void);// An array mapping syscall numbers from syscall.h// to the function that handles the system call.static uint64 (*syscalls[])(void) = {...[SYS_sysinfo]    sys_info,};// 用来在打印trace函数运行结果时输出系统调用名称static char* syscall_names[] = {  ...  \"syscall sysinfo\"};...\n\n\n接着就是实现该系统调用，该系统调用的功能是统计空闲内存和非空闲进程\n统计空闲内存：在kernel/kalloc.c中添加如下函数// 用于统计空闲空间的大小，free_num计算得到的是页数，每页的大小为 4096 bytesuint64free_mem_num(void){  struct run *page;  uint64 free_num = 0;  acquire(&amp;kmem.lock);  // 访问上锁  page = kmem.freelist; // 空闲页面的链表头  while (page) {    free_num++;    page = page-&gt;next;  }  release(&amp;kmem.lock);  // 访问结束解锁          return free_num * 4096;}\n统计非空闲进程：在kernel/proc.c中添加如下函数// 用于统计当前非空闲进程数量uint64proc_used_num(void){  uint64 nproc = 0;  // 计数  for (struct proc *p = proc; p &lt; &amp;proc[NPROC]; p++) {    if (p-&gt;state != UNUSED)      nproc++;  }  return nproc;}\n在实现上述函数后要将二者的声明加入到kernel/defs.h中.\n在kernel/sysproc.c中实现系统调用uint64 sys_info(void):uint64sys_info(void){  // 用户空间指向sysinfo的指针  uint64 u_addr;  argaddr(0, &amp;u_addr);  struct sysinfo info;  info.freemem = free_mem_num(); // 获取空闲内存  info.nproc = proc_used_num();  // 获取非空闲进程  struct proc *p = myproc();  // 根据Hints参考kernel/file.c/filestate()使用copy函数将info复制到用户空间  if(copyout(p-&gt;pagetable, u_addr, (char*)(&amp;info), sizeof(info)) &lt; 0)    return -1;  return 0;}\n\n\n\n\n\n参考链接\nxv6-labs-2022 Lab2 system call 详解\nMIT6.s081-2020 操作系统入门 Lab2 System Calls\n\n\n","categories":["xv6-Lab","操作系统"],"tags":["操作系统","MIT-xv6","c"]},{"title":"C语言函数","url":"/2023/06/05/function%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","content":"函数简介：函数和数学上的函数定义类似，C语言中的函数就是对给定的输入变量,返回对应的函数值,或者对进行一定的操作。\n不同的是在C语言的函数当中，可以为,即没有函数的输入，只是在函数体中进行一定的操作。\n最常见的函数就是main函数，之前讲过每个程序都需要有一个main函数作为程序入口，程序所进行的操作实际就是main函数里的内容。\n函数最大的意义就是可以进行模块化编程，简单来说就是对同一类问题可以只用一个函数求解，类比数学中的函数就是我们对确定的可以只编写一个程序，无论的取值，我们都可以用这一个程序来求解，这一个程序就可以成为一个模块，而需要求解的问题就可以通过对其几个子问题模块的组合来解决。\n函数分类库函数库函数包含在各个头文件里，比如平时最常用的scanf,printf也是函数（包含在&lt;stdio.h&gt;库中），除此之外&lt;cmath&gt;头文件中有定义好的各种数学运算函数，如sqrt(平方根)，floor(下取整)，pow(求幂)等等，还有&lt;cstring&gt;等各种库，只需要记住最常用的一些即可。标准库中的函数我们所要做的就是在程序中包含头文件之后直接调用。\n用户自定义函数这是重点部分，自定义函数就是我们去仿照标准库，去实现一些具有我们想要的功能的函数，具体的定义方法，声明方法等后面补充。\nmain函数程序入口，不再赘述。\n函数的使用：函数的声明和定义void myfunc(void); // 函数的声明（declaration）void myfunc(void)  // 函数的定义（definition） {    printf(\"This is my function...\");    return;}\n\n函数的声明和定义的基本语法如上，声明和定义的区别就是声明告诉了编译器有个函数叫myfunc,但是编译器不一定知道这个函数是做什么的；而定义则不仅告诉了编译器有这个函数，而且告诉了编译器这个函数可以干什么。\n之后我们细看函数定义的语法，void myfunc(void)中，前面的void代表的是返回值类型（Return Type），后面的void代表的是函数参数(Parameters)。函数的返回值可以理解为，而函数参数就可以理解为,若有多个参数用,隔开。\n返回值类型就是C语言中的数据类型，比如int,float,double,char等等，而参数则可以有多个，对应数学中的多元函数，下面给出一个求圆面积的例子：\n#define PI 3.1415926double getCircleArea(double radius){    double area = PI * radius * radius;    return area;}\n\n需要注意的是函数定义的返回值类型和在函数体中返回的类型要一致，如上面的例子中，圆面积area是double类型，函数的返回值也是double类型，因此函数体返回的语句为return area.再比如main函数一般为int main(),return 0;。\n回到开始的例子，\nvoid myfunc(void) {    printf(\"This is my function...\");    return;}\n\n之前知道C语言中void代表忽略或者没有，所以这个例子中的函数1.不需要参数。2.没有返回值。\n函数的调用：自定义函数在程序中的结构1.#include &lt;stdio.h&gt;// 函数的声明int main(){    // 调用函数    return 0;}// 函数的定义\n\neg:\n#include &lt;stdio.h&gt;void myfunc(); // 声明int main(){    myfunc();    return 0;}void myfunc(){    // To do ...    return;}\n\n2.#include &lt;stdio.h&gt;// 函数的声明兼定义int main(){    // 调用函数    return 0;}\n\neg:\n#include &lt;stdio.h&gt;void myfunc(){    // To do ...    return;}int main(){    myfunc();    return 0;}\n\n调用时返回值类型与等号左值相对应eg:\n#include &lt;stdio.h&gt;#define PI 3.1415926double getCircleArea(double radius){    double area = PI * radius * radius;    return area;}int main(){    double radius = 4;    double area = getCircleArea(radius);    return 0;}\n\n嵌套调用：函数不止在主函数中可以调用，在一个函数中可以调用另一个函数eg:见ppt Page.19\n需要注意的是如果函数A在函数B中被调用,A一定要在B的定义之前被声明。\n变量：形参和实参：形参是指函数定义和声明中的参数，而实参是指调用函数时传入的参数\neg:\n#include &lt;stdio.h&gt;int add(int A, int B){    return A + B;}int main(){    int a = 4, b = 5;    int c = add(a, b);    return 0;}\n\n上述代码中A,B为形参， a,b为实参。（形参和实参可以同名）\n变量的作用域：一般来说，变量的作用域就是定义变量的那一个语句块（那一对大括号之间）。\neg:\n#include &lt;stdio.h&gt;int global;int main(){    int a;    if(a == 0)    {        int b;    }    else    {        int c;    }    return 0;}\n\n如上述例子，变量a的作用域是整个main函数，而b，c的作用域则是它们各自所在的if语句块。\na,b,c都统称局部变量，除此之外，也有特殊变量叫全局变量，它定义在main函数之前，作用域是整个程序。\n注意，自定义函数的参数属于局部变量，它的作用域就是函数体内。\n变量类型：auto和register逐渐弃用，看看ppt就行\nstatic:用在局部变量，延长变量寿命，在函数体中的变量若没有static,每次调用后都会被释放，每次调用时都是重新申请资源，而static修饰后每次调用都是在上次调用的基础上。\n用在全局变量，单文件没影响，多文件本来全局变量是多个文件互通，加static修饰后只在当前文件内可用。\nextern:在其他文件内定义的变量使用前声明时用到extern.\n","categories":["语法总结","C语言"],"tags":["C语言"]},{"title":"Hello World","url":"/2023/06/05/hello-world/","content":"经典Hello World开局cout&lt;&lt;\"Hello World\"&lt;&lt;endl;\n","categories":["杂谈"],"tags":["hello world"]},{"title":"VMware 让虚拟机通过主机代理上网","url":"/2023/06/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware-%E7%94%A8%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/","content":"Ubuntu 20.04.6 LTS\nVMware Workstation 17 Pro 17.0.0\nwindows 10\n首先更改虚拟机的网络适配器设置如下：\n\n之后打开代理软件，允许局域网连接并记录端口号（v2rayN为例）：\n\n命令行输入ipconfig，得到主机ip地址：\n\n打开Ubuntu网络设置，代理设置改为手动，输入本机ip地址，只需要填端口号即可：\n\n需要注意，虽然之前得到监听端口为8888,但在v2rayN中局域网连接的端口一般为为监听端口+2~+3，因此此处端口为8890，如下图：\n\n至此虚拟机就可以用宿主机的代理愉快上网啦：\n\n","categories":["虚拟机"],"tags":["虚拟机","VMware"]},{"title":"洛谷P1124题解——文件压缩","url":"/2023/06/05/%E6%B4%9B%E8%B0%B7P1124%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/","content":"题目原题链接：P1124-文件压缩\n原题：\n题目描述\n该算法具体如下：对一个长度为 n 的字符串 S，首先根据它构造 n 个字符串，其中第 i 个字符串由将 S 的前 i−1 个字符置于末尾得到。然后把这 n 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们在 S 中的位置从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 S′，它的长度也是 n，并且包含了 S 中的每一个字符。最后输出 S′ 以及 S 的首字符在 S′ 中的位置 p。\n举例：S 是 example\n\n构造 n 个字符串。\nexamplexampleeampleexmpleexapleexamleexampeexampl\n将字符串排序。\nampleexexampleeexamplleexampmpleexapleexamxamplee\n压缩结果。\n，\n\n\n在读题过程中不难发现，当我们将压缩结果按字典序排列时可以得到中首字母序列，从而我们可以得到每个字母的前驱或者后继。因此我们可以利用这个规律来找到原字符串。这里我们选择先找到尾字符，然后找每个字母的前驱，最后反向输出，这样做的原因是正向寻找时按照压缩字符串寻找，无规律，容易乱序，而逆向寻找靠排序串，不致乱序。\nc++实现#include&lt;bits/stdc++.h&gt;//可食用头文件using namespace std;int main(){    int n,shou,now;//n为S串长度，shou即为题目中p，首字母所在压缩后的位置，now为现在进行到哪个位置了    cin&gt;&gt;n;//输入    char a[n],b[n],ans[n];//a——压缩串，b——字典序串，ans——答案串    cin&gt;&gt;a&gt;&gt;shou;//万能cin    for(int i=0;i&lt;n;i++)b[i]=a[i];//a带给b    sort(b,b+n);//自动排序    for(int i=0;i&lt;n;i++)//首先按首字母找到最后一个字母    {        if(b[i]==a[shou-1])        {            now=i;            b[i]=')';//标记，退出            break;        }    }    ans[0]=a[now];//计入答案    for(int i=1;i&lt;n;i++)//ans[i]表示倒数第i+1个字母    {        for(int j=n-1;j&gt;=0;j--)//从后往前搜到第一个与原char串匹配的字典序串        {            if(b[j]==a[now])            {                now=j;//更改现在所在位置，即跳到前一个字母                ans[i]=a[now];//计入答案                b[j]=')';//标记                break;            }        }        }    for(int i=n-1;i&gt;=0;i--)cout&lt;&lt;ans[i];//倒序输出}\npython实现n=int(input())#字符串长度s=input()#压缩串pos=int(input())#压缩串中首字母位置pos=pos-1box=[]#压缩串得到列表for i in range(n):    box.append(s[i])boxs=box.copy()boxs.sort()#字典序列表res=[]for i in range(0,n):    if boxs[i]==box[pos]:        pos=i        boxs[i]='0'        res.append(box[pos])        break    for j in range(1,n):    for i in range(n-1,-1,-1):        if boxs[i]==box[pos]:            pos=i            res.append(box[pos])            boxs[i]='0'            break            ans=\"\"res.reverse()for each in res:    ans=ans+eachprint(ans)\n","categories":["题解"],"tags":["python","洛谷","c++"]}]